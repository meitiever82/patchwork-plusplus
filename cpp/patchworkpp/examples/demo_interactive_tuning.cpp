#include <fstream>
#include <iostream>
#include <thread>
#include <chrono>

#include <open3d/Open3D.h>
#include <opencv2/opencv.hpp>
#include <patchwork/patchworkpp.h>

using namespace open3d;

// 全局变量存储参数和数据
struct TuningParams {
    // Patchwork++ 参数
    float sensor_height = 1.2f;
    float th_seeds = 0.5f;
    float th_dist = 0.3f;
    float th_seeds_v = 0.4f;
    float th_dist_v = 0.3f;
    float uprightness_thr = 0.707f;
    float max_range = 80.0f;
    float min_range = 0.3f;
    
    // 网格地图参数
    float height_threshold = 3.5f;
    float resolution = 0.1f;
    
    // 形态学参数
    int opening_size = 2;
    int closing_size = 4;
    int dilation_size = 1;
    
    // 边界优化参数
    bool enable_boundary_connect = true;
    bool enable_boundary_smooth = true;
    float boundary_epsilon = 0.02f;
    
    // 文件管理
    std::string param_file_path = "default_params.txt";
    std::string output_path = "interactive_output";
    
    // 显示参数
    bool show_ground = true;
    bool show_obstacles = true;
    bool show_centers = true;
};

// 读取参数文件
bool loadParamsFromFile(const std::string& filepath, TuningParams& params) {
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cout << "Warning: Could not open parameter file: " << filepath << std::endl;
        std::cout << "Using default parameters." << std::endl;
        return false;
    }
    
    std::string line;
    int loaded_count = 0;
    
    while (std::getline(file, line)) {
        // 跳过注释和空行
        if (line.empty() || line[0] == '#') continue;
        
        size_t pos = line.find('=');
        if (pos == std::string::npos) continue;
        
        std::string key = line.substr(0, pos);
        std::string value = line.substr(pos + 1);
        
        // 解析参数
        if (key == "sensor_height") {
            params.sensor_height = std::stof(value);
            loaded_count++;
        } else if (key == "th_seeds") {
            params.th_seeds = std::stof(value);
            loaded_count++;
        } else if (key == "th_dist") {
            params.th_dist = std::stof(value);
            loaded_count++;
        } else if (key == "th_seeds_v") {
            params.th_seeds_v = std::stof(value);
            loaded_count++;
        } else if (key == "th_dist_v") {
            params.th_dist_v = std::stof(value);
            loaded_count++;
        } else if (key == "uprightness_thr") {
            params.uprightness_thr = std::stof(value);
            loaded_count++;
        } else if (key == "max_range") {
            params.max_range = std::stof(value);
            loaded_count++;
        } else if (key == "min_range") {
            params.min_range = std::stof(value);
            loaded_count++;
        } else if (key == "height_threshold") {
            params.height_threshold = std::stof(value);
            loaded_count++;
        } else if (key == "resolution") {
            params.resolution = std::stof(value);
            loaded_count++;
        } else if (key == "opening_size") {
            params.opening_size = std::stoi(value);
            loaded_count++;
        } else if (key == "closing_size") {
            params.closing_size = std::stoi(value);
            loaded_count++;
        } else if (key == "dilation_size") {
            params.dilation_size = std::stoi(value);
            loaded_count++;
        } else if (key == "output_path") {
            params.output_path = value;
            loaded_count++;
        }
    }
    
    file.close();
    std::cout << "Loaded " << loaded_count << " parameters from: " << filepath << std::endl;
    return true;
}

// 保存参数到文件
void saveParamsToFile(const std::string& filepath, const TuningParams& params) {
    std::ofstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "Error: Could not save parameters to: " << filepath << std::endl;
        return;
    }
    
    file << "# Patchwork++ Parameters - Generated by Interactive Tuning" << std::endl;
    file << "# Timestamp: " << std::time(nullptr) << std::endl << std::endl;
    
    file << "# Patchwork++ Core Parameters" << std::endl;
    file << "sensor_height=" << params.sensor_height << std::endl;
    file << "th_seeds=" << params.th_seeds << std::endl;
    file << "th_dist=" << params.th_dist << std::endl;
    file << "th_seeds_v=" << params.th_seeds_v << std::endl;
    file << "th_dist_v=" << params.th_dist_v << std::endl;
    file << "uprightness_thr=" << params.uprightness_thr << std::endl;
    file << "max_range=" << params.max_range << std::endl;
    file << "min_range=" << params.min_range << std::endl;
    file << std::endl;
    
    file << "# Grid Map Parameters" << std::endl;
    file << "height_threshold=" << params.height_threshold << std::endl;
    file << "resolution=" << params.resolution << std::endl;
    file << std::endl;
    
    file << "# Morphological Parameters" << std::endl;
    file << "opening_size=" << params.opening_size << std::endl;
    file << "closing_size=" << params.closing_size << std::endl;
    file << "dilation_size=" << params.dilation_size << std::endl;
    file << std::endl;
    
    file << "# Output Parameters" << std::endl;
    file << "output_path=" << params.output_path << std::endl;
    
    file.close();
    std::cout << "Parameters saved to: " << filepath << std::endl;
}

// 全局数据
Eigen::MatrixXf g_cloud;
std::string g_cloud_path;
TuningParams g_params;
cv::Mat g_current_gridmap;
bool g_params_changed = true;

// 文本输入相关
struct TextInputState {
    bool param_file_active = false;
    bool output_path_active = false;
    std::string param_file_buffer;
    std::string output_path_buffer;
    int cursor_pos = 0;
};
TextInputState g_input_state;

// 读取PCD文件
void read_pcd(const std::string pcd_path, Eigen::MatrixXf& cloud) {
    auto pcd = io::CreatePointCloudFromFile(pcd_path);
    if (pcd->IsEmpty()) {
        std::cerr << "error: failed to load " << pcd_path << std::endl;
        return;
    }

    cloud.resize(pcd->points_.size(), 3);
    for (size_t i = 0; i < pcd->points_.size(); i++) {
        cloud.row(i) << pcd->points_[i](0), pcd->points_[i](1), pcd->points_[i](2);
    }
}

// 生成网格地图（简化版本）
cv::Mat generateQuickGridMap(const Eigen::MatrixX3f& ground_points, 
                             const Eigen::MatrixX3f& nonground_points,
                             const TuningParams& params) {
    
    // 计算边界框
    float min_x = std::numeric_limits<float>::max();
    float max_x = std::numeric_limits<float>::lowest();
    float min_y = std::numeric_limits<float>::max();
    float max_y = std::numeric_limits<float>::lowest();

    for (int i = 0; i < ground_points.rows(); ++i) {
        min_x = std::min(min_x, ground_points(i, 0));
        max_x = std::max(max_x, ground_points(i, 0));
        min_y = std::min(min_y, ground_points(i, 1));
        max_y = std::max(max_y, ground_points(i, 1));
    }

    for (int i = 0; i < nonground_points.rows(); ++i) {
        if (nonground_points(i, 2) <= params.height_threshold) {
            min_x = std::min(min_x, nonground_points(i, 0));
            max_x = std::max(max_x, nonground_points(i, 0));
            min_y = std::min(min_y, nonground_points(i, 1));
            max_y = std::max(max_y, nonground_points(i, 1));
        }
    }

    // 添加边距
    float margin_x = (max_x - min_x) * 0.1;
    float margin_y = (max_y - min_y) * 0.1;
    min_x -= margin_x;
    max_x += margin_x;
    min_y -= margin_y;
    max_y += margin_y;

    // 创建网格
    int map_width = static_cast<int>((max_x - min_x) / params.resolution);
    int map_height = static_cast<int>((max_y - min_y) / params.resolution);
    
    cv::Mat grid_map = cv::Mat::ones(map_height, map_width, CV_8UC1) * 100; // unknown

    // 投影地面点
    for (int i = 0; i < ground_points.rows(); ++i) {
        int grid_x = static_cast<int>((ground_points(i, 0) - min_x) / params.resolution);
        int grid_y = static_cast<int>((ground_points(i, 1) - min_y) / params.resolution);
        
        if (grid_x >= 0 && grid_x < map_width && grid_y >= 0 && grid_y < map_height) {
            grid_map.at<uint8_t>(grid_y, grid_x) = 0; // ground
        }
    }

    // 投影非地面点
    for (int i = 0; i < nonground_points.rows(); ++i) {
        if (nonground_points(i, 2) > params.height_threshold) continue;
        
        int grid_x = static_cast<int>((nonground_points(i, 0) - min_x) / params.resolution);
        int grid_y = static_cast<int>((nonground_points(i, 1) - min_y) / params.resolution);
        
        if (grid_x >= 0 && grid_x < map_width && grid_y >= 0 && grid_y < map_height) {
            if (grid_map.at<uint8_t>(grid_y, grid_x) == 100) { // only if unknown
                grid_map.at<uint8_t>(grid_y, grid_x) = 200; // obstacle
            }
        }
    }

    // 形态学操作
    if (params.opening_size > 0) {
        cv::Mat ground_mask = (grid_map == 0);
        cv::Mat obstacle_mask = (grid_map == 200);
        
        cv::Mat opening_kernel = cv::getStructuringElement(cv::MORPH_RECT, 
            cv::Size(params.opening_size, params.opening_size));
        cv::Mat closing_kernel = cv::getStructuringElement(cv::MORPH_RECT, 
            cv::Size(params.closing_size, params.closing_size));
        
        cv::morphologyEx(ground_mask, ground_mask, cv::MORPH_OPEN, opening_kernel);
        cv::morphologyEx(obstacle_mask, obstacle_mask, cv::MORPH_OPEN, opening_kernel);
        cv::morphologyEx(ground_mask, ground_mask, cv::MORPH_CLOSE, closing_kernel);
        cv::morphologyEx(obstacle_mask, obstacle_mask, cv::MORPH_CLOSE, closing_kernel);
        
        // 重建地图
        grid_map.setTo(100); // unknown
        grid_map.setTo(0, ground_mask);     // ground
        grid_map.setTo(200, obstacle_mask); // obstacles
    }

    return grid_map;
}

// 滑条回调函数
void onParamChange(int val, void* userdata) {
    g_params_changed = true;
}

// 绘制文本输入框
void drawTextInput(cv::Mat& img, const std::string& label, const std::string& text, 
                  int x, int y, int width, int height, bool active, int cursor_pos = 0) {
    // 绘制背景框
    cv::Scalar bg_color = active ? cv::Scalar(255, 255, 255) : cv::Scalar(240, 240, 240);
    cv::Scalar text_color = cv::Scalar(0, 0, 0);
    cv::Scalar border_color = active ? cv::Scalar(0, 120, 255) : cv::Scalar(128, 128, 128);
    
    cv::rectangle(img, cv::Rect(x, y, width, height), bg_color, -1);
    cv::rectangle(img, cv::Rect(x, y, width, height), border_color, active ? 2 : 1);
    
    // 绘制标签
    cv::putText(img, label, cv::Point(x, y - 5), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0), 1);
    
    // 绘制文本
    std::string display_text = text;
    if (display_text.length() > 50) {
        display_text = "..." + display_text.substr(display_text.length() - 47);
    }
    
    cv::putText(img, display_text, cv::Point(x + 5, y + height/2 + 5), 
                cv::FONT_HERSHEY_SIMPLEX, 0.4, text_color, 1);
    
    // 绘制光标（如果激活）
    if (active) {
        int text_width = cv::getTextSize(display_text.substr(0, cursor_pos), 
                                        cv::FONT_HERSHEY_SIMPLEX, 0.4, 1, nullptr).width;
        cv::line(img, cv::Point(x + 5 + text_width, y + 5), 
                 cv::Point(x + 5 + text_width, y + height - 5), cv::Scalar(0, 0, 0), 1);
    }
}

// 鼠标回调函数
void onMouse(int event, int x, int y, int flags, void* userdata) {
    if (event == cv::EVENT_LBUTTONDOWN) {
        // 检查参数文件输入框
        if (x >= 10 && x <= 400 && y >= 80 && y <= 110) {
            g_input_state.param_file_active = true;
            g_input_state.output_path_active = false;
            g_input_state.param_file_buffer = g_params.param_file_path;
            g_input_state.cursor_pos = g_input_state.param_file_buffer.length();
        }
        // 检查输出路径输入框
        else if (x >= 10 && x <= 400 && y >= 130 && y <= 160) {
            g_input_state.param_file_active = false;
            g_input_state.output_path_active = true;
            g_input_state.output_path_buffer = g_params.output_path;
            g_input_state.cursor_pos = g_input_state.output_path_buffer.length();
        }
        // 点击其他地方取消激活
        else {
            g_input_state.param_file_active = false;
            g_input_state.output_path_active = false;
        }
    }
}

// 处理文本输入
void handleTextInput(int key) {
    std::string* active_buffer = nullptr;
    if (g_input_state.param_file_active) {
        active_buffer = &g_input_state.param_file_buffer;
    } else if (g_input_state.output_path_active) {
        active_buffer = &g_input_state.output_path_buffer;
    }
    
    if (!active_buffer) return;
    
    if (key == 8 || key == 127) { // Backspace or Delete
        if (g_input_state.cursor_pos > 0 && !active_buffer->empty()) {
            active_buffer->erase(g_input_state.cursor_pos - 1, 1);
            g_input_state.cursor_pos--;
        }
    } else if (key == 13) { // Enter - 确认输入
        if (g_input_state.param_file_active) {
            std::string old_file = g_params.param_file_path;
            g_params.param_file_path = g_input_state.param_file_buffer;
            
            // 尝试加载新参数文件
            if (loadParamsFromFile(g_params.param_file_path, g_params)) {
                // 更新所有滑条
                cv::setTrackbarPos("Sensor Height (*100)", "Patchwork++ Parameters", (int)(g_params.sensor_height * 100));
                cv::setTrackbarPos("TH Seeds (*100)", "Patchwork++ Parameters", (int)(g_params.th_seeds * 100));
                cv::setTrackbarPos("TH Dist (*100)", "Patchwork++ Parameters", (int)(g_params.th_dist * 100));
                cv::setTrackbarPos("Uprightness (*100)", "Patchwork++ Parameters", (int)(g_params.uprightness_thr * 100));
                cv::setTrackbarPos("Height Threshold (*10)", "Patchwork++ Parameters", (int)(g_params.height_threshold * 10));
                cv::setTrackbarPos("Resolution (*100)", "Patchwork++ Parameters", (int)(g_params.resolution * 100));
                cv::setTrackbarPos("Opening Size", "Patchwork++ Parameters", g_params.opening_size);
                cv::setTrackbarPos("Closing Size", "Patchwork++ Parameters", g_params.closing_size);
                cv::setTrackbarPos("Dilation Size", "Patchwork++ Parameters", g_params.dilation_size);
                g_params_changed = true;
                std::cout << "Loaded new parameter file: " << g_params.param_file_path << std::endl;
            } else {
                g_params.param_file_path = old_file; // 恢复原文件路径
                std::cout << "Failed to load parameter file, keeping current settings." << std::endl;
            }
        } else if (g_input_state.output_path_active) {
            g_params.output_path = g_input_state.output_path_buffer;
            std::cout << "Output path updated to: " << g_params.output_path << std::endl;
        }
        
        g_input_state.param_file_active = false;
        g_input_state.output_path_active = false;
    } else if (key >= 32 && key < 127) { // 可打印字符
        if (active_buffer->length() < 200) { // 限制长度
            active_buffer->insert(g_input_state.cursor_pos, 1, static_cast<char>(key));
            g_input_state.cursor_pos++;
        }
    }
}

// 处理和更新显示
void updateDisplay() {
    if (!g_params_changed) return;
    
    auto start_time = std::chrono::high_resolution_clock::now();
    
    // 设置Patchwork++参数
    patchwork::Params patchwork_parameters;
    patchwork_parameters.sensor_height = g_params.sensor_height;
    patchwork_parameters.th_seeds = g_params.th_seeds;
    patchwork_parameters.th_dist = g_params.th_dist;
    patchwork_parameters.th_seeds_v = g_params.th_seeds_v;
    patchwork_parameters.th_dist_v = g_params.th_dist_v;
    patchwork_parameters.uprightness_thr = g_params.uprightness_thr;
    patchwork_parameters.max_range = g_params.max_range;
    patchwork_parameters.min_range = g_params.min_range;
    patchwork_parameters.num_iter = 3;
    patchwork_parameters.num_lpr = 20;
    patchwork_parameters.num_min_pts = 10;
    patchwork_parameters.adaptive_seed_selection_margin = -1.2;
    patchwork_parameters.num_zones = 4;
    patchwork_parameters.num_sectors_each_zone = {16, 32, 54, 32};
    patchwork_parameters.num_rings_each_zone = {2, 4, 4, 4};
    patchwork_parameters.elevation_thr = {0.523, 0.746, 0.879, 1.125};
    patchwork_parameters.flatness_thr = {0.0005, 0.000725, 0.001, 0.001};
    patchwork_parameters.enable_RNR = true;
    patchwork_parameters.enable_TGR = true;
    patchwork_parameters.enable_RVPF = true;
    patchwork_parameters.RNR_ver_angle_thr = -15.0;
    patchwork_parameters.RNR_intensity_thr = 0.2;
    patchwork_parameters.num_rings_of_interest = 4;
    patchwork_parameters.max_flatness_storage = 1000;
    patchwork_parameters.max_elevation_storage = 1000;
    patchwork_parameters.verbose = false; // 关闭详细输出
    
    // 运行Patchwork++
    patchwork::PatchWorkpp Patchworkpp(patchwork_parameters);
    Patchworkpp.estimateGround(g_cloud);
    
    // 获取结果
    Eigen::MatrixX3f ground = Patchworkpp.getGround();
    Eigen::MatrixX3f nonground = Patchworkpp.getNonground();
    double time_taken = Patchworkpp.getTimeTaken();
    
    // 生成网格地图
    g_current_gridmap = generateQuickGridMap(ground, nonground, g_params);
    
    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    
    // 创建显示图像
    cv::Mat display_map;
    cv::resize(g_current_gridmap, display_map, cv::Size(800, 600));
    cv::flip(display_map, display_map, 0); // 翻转Y轴
    
    // 添加颜色映射
    cv::Mat colored_map;
    cv::applyColorMap(display_map, colored_map, cv::COLORMAP_JET);
    
    // 添加统计信息和文件信息
    std::string info_text = "Ground: " + std::to_string(ground.rows()) + 
                           " | Obstacles: " + std::to_string(nonground.rows()) +
                           " | Time: " + std::to_string(duration.count()) + "ms";
    
    std::string file_info = "Params: " + g_params.param_file_path + " | Output: " + g_params.output_path;
    std::string pcd_info = "PCD: " + g_cloud_path.substr(g_cloud_path.find_last_of("/\\") + 1);
    
    cv::putText(colored_map, info_text, cv::Point(10, 25), 
                cv::FONT_HERSHEY_SIMPLEX, 0.6, cv::Scalar(255, 255, 255), 2);
    cv::putText(colored_map, file_info, cv::Point(10, 50), 
                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    cv::putText(colored_map, pcd_info, cv::Point(10, 70), 
                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(200, 200, 200), 1);
    
    // 添加文本输入框区域（在底部）
    cv::Rect input_area(0, colored_map.rows - 120, colored_map.cols, 120);
    cv::rectangle(colored_map, input_area, cv::Scalar(50, 50, 50), -1); // 深灰背景
    
    // 绘制参数文件输入框
    std::string param_display = g_input_state.param_file_active ? 
                               g_input_state.param_file_buffer : g_params.param_file_path;
    drawTextInput(colored_map, "Parameter File:", param_display,
                  10, colored_map.rows - 110, 400, 30, 
                  g_input_state.param_file_active, g_input_state.cursor_pos);
    
    // 绘制输出路径输入框
    std::string output_display = g_input_state.output_path_active ? 
                                g_input_state.output_path_buffer : g_params.output_path;
    drawTextInput(colored_map, "Output Path:", output_display,
                  10, colored_map.rows - 70, 400, 30, 
                  g_input_state.output_path_active, g_input_state.cursor_pos);
    
    // 添加使用说明
    cv::putText(colored_map, "Click textbox to edit, Enter to confirm, Esc to cancel", 
                cv::Point(10, colored_map.rows - 15), 
                cv::FONT_HERSHEY_SIMPLEX, 0.4, cv::Scalar(180, 180, 180), 1);
    
    cv::imshow("Grid Map (Real-time)", colored_map);
    cv::imshow("Grid Map (Grayscale)", display_map);
    
    g_params_changed = false;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cout << "Usage: " << argv[0] << " <point_cloud_file.pcd> [param_file.txt]" << std::endl;
        std::cout << "  point_cloud_file.pcd - Input PCD file" << std::endl;
        std::cout << "  param_file.txt       - Optional parameter file (default: default_params.txt)" << std::endl;
        return -1;
    }
    
    g_cloud_path = argv[1];
    
    // 设置参数文件路径
    if (argc >= 3) {
        g_params.param_file_path = argv[2];
    }
    
    // 读取参数文件
    if (!loadParamsFromFile(g_params.param_file_path, g_params)) {
        std::cout << "Continuing with default parameters..." << std::endl;
    }
    
    // 加载点云
    std::cout << "Loading point cloud: " << g_cloud_path << std::endl;
    read_pcd(g_cloud_path, g_cloud);
    
    if (g_cloud.rows() == 0) {
        std::cerr << "Failed to load point cloud!" << std::endl;
        return -1;
    }
    
    std::cout << "Loaded " << g_cloud.rows() << " points" << std::endl;
    
    // 创建控制窗口
    cv::namedWindow("Patchwork++ Parameters", cv::WINDOW_NORMAL);
    cv::resizeWindow("Patchwork++ Parameters", 500, 800);
    
    // 创建显示窗口
    cv::namedWindow("Grid Map (Real-time)", cv::WINDOW_NORMAL);
    cv::namedWindow("Grid Map (Grayscale)", cv::WINDOW_NORMAL);
    
    // 设置鼠标回调
    cv::setMouseCallback("Grid Map (Real-time)", onMouse, nullptr);
    
    // 根据读取的参数初始化滑条
    // Patchwork++参数滑条 (放大100倍用于整数滑条)
    cv::createTrackbar("Sensor Height (*100)", "Patchwork++ Parameters", 
                       nullptr, 300, onParamChange);
    cv::setTrackbarPos("Sensor Height (*100)", "Patchwork++ Parameters", (int)(g_params.sensor_height * 100));
    
    cv::createTrackbar("TH Seeds (*100)", "Patchwork++ Parameters", 
                       nullptr, 200, onParamChange);
    cv::setTrackbarPos("TH Seeds (*100)", "Patchwork++ Parameters", (int)(g_params.th_seeds * 100));
    
    cv::createTrackbar("TH Dist (*100)", "Patchwork++ Parameters", 
                       nullptr, 100, onParamChange);
    cv::setTrackbarPos("TH Dist (*100)", "Patchwork++ Parameters", (int)(g_params.th_dist * 100));
    
    cv::createTrackbar("Uprightness (*100)", "Patchwork++ Parameters", 
                       nullptr, 100, onParamChange);
    cv::setTrackbarPos("Uprightness (*100)", "Patchwork++ Parameters", (int)(g_params.uprightness_thr * 100));
    
    // 网格地图参数
    cv::createTrackbar("Height Threshold (*10)", "Patchwork++ Parameters", 
                       nullptr, 100, onParamChange);
    cv::setTrackbarPos("Height Threshold (*10)", "Patchwork++ Parameters", (int)(g_params.height_threshold * 10));
    
    cv::createTrackbar("Resolution (*100)", "Patchwork++ Parameters", 
                       nullptr, 50, onParamChange);
    cv::setTrackbarPos("Resolution (*100)", "Patchwork++ Parameters", (int)(g_params.resolution * 100));
    
    // 形态学参数
    cv::createTrackbar("Opening Size", "Patchwork++ Parameters", 
                       nullptr, 10, onParamChange);
    cv::setTrackbarPos("Opening Size", "Patchwork++ Parameters", g_params.opening_size);
    
    cv::createTrackbar("Closing Size", "Patchwork++ Parameters", 
                       nullptr, 10, onParamChange);
    cv::setTrackbarPos("Closing Size", "Patchwork++ Parameters", g_params.closing_size);
    
    cv::createTrackbar("Dilation Size", "Patchwork++ Parameters", 
                       nullptr, 5, onParamChange);
    cv::setTrackbarPos("Dilation Size", "Patchwork++ Parameters", g_params.dilation_size);
    
    std::cout << "\\n=== Interactive Parameter Tuning ===" << std::endl;
    std::cout << "Parameters loaded from: " << g_params.param_file_path << std::endl;
    std::cout << "Output path: " << g_params.output_path << std::endl;
    std::cout << "\\nControls:" << std::endl;
    std::cout << "  's' - Save parameters to '" << g_params.param_file_path << "'" << std::endl;
    std::cout << "  'r' - Reload parameters from file" << std::endl;
    std::cout << "  'w' - Save grid map to output path" << std::endl;
    std::cout << "  'p' - Print current parameters" << std::endl;
    std::cout << "  ESC - Exit application" << std::endl;
    std::cout << "\\nReal-time preview: Adjust trackbars to see immediate results!" << std::endl;
    
    // 主循环
    while (true) {
        // 获取滑条值并更新参数
        g_params.sensor_height = cv::getTrackbarPos("Sensor Height (*100)", "Patchwork++ Parameters") / 100.0f;
        g_params.th_seeds = cv::getTrackbarPos("TH Seeds (*100)", "Patchwork++ Parameters") / 100.0f;
        g_params.th_dist = cv::getTrackbarPos("TH Dist (*100)", "Patchwork++ Parameters") / 100.0f;
        g_params.uprightness_thr = cv::getTrackbarPos("Uprightness (*100)", "Patchwork++ Parameters") / 100.0f;
        g_params.height_threshold = cv::getTrackbarPos("Height Threshold (*10)", "Patchwork++ Parameters") / 10.0f;
        g_params.resolution = cv::getTrackbarPos("Resolution (*100)", "Patchwork++ Parameters") / 100.0f;
        
        // 更新显示
        updateDisplay();
        
        // 处理按键
        int key = cv::waitKey(30) & 0xFF;
        if (key == 27) { // ESC
            if (g_input_state.param_file_active || g_input_state.output_path_active) {
                // 取消文本输入
                g_input_state.param_file_active = false;
                g_input_state.output_path_active = false;
                std::cout << "Text input cancelled" << std::endl;
            } else {
                break;
            }
        } else if (key == 's') { // Save parameters to file
            saveParamsToFile(g_params.param_file_path, g_params);
            
        } else if (key == 'r') { // Reload parameters from file
            std::cout << "Reloading parameters from: " << g_params.param_file_path << std::endl;
            TuningParams reloaded_params = g_params; // 保留文件路径
            if (loadParamsFromFile(g_params.param_file_path, reloaded_params)) {
                reloaded_params.param_file_path = g_params.param_file_path; // 保持文件路径不变
                reloaded_params.output_path = g_params.output_path;         // 保持输出路径不变
                g_params = reloaded_params;
                
                // 更新滑条位置
                cv::setTrackbarPos("Sensor Height (*100)", "Patchwork++ Parameters", (int)(g_params.sensor_height * 100));
                cv::setTrackbarPos("TH Seeds (*100)", "Patchwork++ Parameters", (int)(g_params.th_seeds * 100));
                cv::setTrackbarPos("TH Dist (*100)", "Patchwork++ Parameters", (int)(g_params.th_dist * 100));
                cv::setTrackbarPos("Uprightness (*100)", "Patchwork++ Parameters", (int)(g_params.uprightness_thr * 100));
                cv::setTrackbarPos("Height Threshold (*10)", "Patchwork++ Parameters", (int)(g_params.height_threshold * 10));
                cv::setTrackbarPos("Resolution (*100)", "Patchwork++ Parameters", (int)(g_params.resolution * 100));
                cv::setTrackbarPos("Opening Size", "Patchwork++ Parameters", g_params.opening_size);
                cv::setTrackbarPos("Closing Size", "Patchwork++ Parameters", g_params.closing_size);
                cv::setTrackbarPos("Dilation Size", "Patchwork++ Parameters", g_params.dilation_size);
                g_params_changed = true;
                std::cout << "Parameters reloaded successfully!" << std::endl;
            }
            
        } else if (key == 'w') { // Save current grid map
            if (!g_current_gridmap.empty()) {
                // 创建输出目录
                std::string mkdir_cmd = "mkdir -p " + g_params.output_path;
                system(mkdir_cmd.c_str());
                
                // 生成带时间戳的文件名
                auto now = std::time(nullptr);
                std::string timestamp = std::to_string(now);
                std::string base_name = g_params.output_path + "/gridmap_" + timestamp;
                
                // 保存PGM格式 (ROS兼容)
                cv::Mat flipped_map;
                cv::flip(g_current_gridmap, flipped_map, 0);
                cv::imwrite(base_name + ".pgm", flipped_map);
                
                // 保存PNG格式 (可视化)
                cv::Mat display_map;
                cv::resize(g_current_gridmap, display_map, cv::Size(800, 600));
                cv::flip(display_map, display_map, 0);
                cv::imwrite(base_name + "_vis.png", display_map);
                
                std::cout << "Grid map saved to:" << std::endl;
                std::cout << "  " << base_name << ".pgm (ROS format)" << std::endl;
                std::cout << "  " << base_name << "_vis.png (visualization)" << std::endl;
            }
            
        } else if (key == 'p') { // Print current parameters
            std::cout << "\\n=== Current Parameters ===" << std::endl;
            std::cout << "sensor_height=" << g_params.sensor_height << std::endl;
            std::cout << "th_seeds=" << g_params.th_seeds << std::endl;
            std::cout << "th_dist=" << g_params.th_dist << std::endl;
            std::cout << "th_seeds_v=" << g_params.th_seeds_v << std::endl;
            std::cout << "th_dist_v=" << g_params.th_dist_v << std::endl;
            std::cout << "uprightness_thr=" << g_params.uprightness_thr << std::endl;
            std::cout << "height_threshold=" << g_params.height_threshold << std::endl;
            std::cout << "resolution=" << g_params.resolution << std::endl;
            std::cout << "opening_size=" << g_params.opening_size << std::endl;
            std::cout << "closing_size=" << g_params.closing_size << std::endl;
            std::cout << "dilation_size=" << g_params.dilation_size << std::endl;
            std::cout << "========================" << std::endl;
        } else {
            // 处理文本输入（如果有输入框激活）
            if (g_input_state.param_file_active || g_input_state.output_path_active) {
                handleTextInput(key);
            }
        }
    }
    
    cv::destroyAllWindows();
    return 0;
}